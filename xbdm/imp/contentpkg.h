/************************************************************************
*                                                                       *
*   contentpkg.h -- Xenon Content Package Definition                    *
*                                                                       *
*   Copyright (c) Microsoft Corp. All rights reserved.                  *
*                                                                       *
************************************************************************/

#ifndef _CONTENTPKG_H_
#define _CONTENTPKG_H_

#include "consolecert.h"

#pragma pack(push, 1)

//
// Everything in the header is stored in big-endian format.
//

//------------------------------------------------------------------------------
typedef enum _XCONTENT_SIGNATURE_TYPE
{
    CONSOLE_SIGNED          = 'CON ',
    LIVE_SIGNED             = 'LIVE',
    PIRS_SIGNED             = 'PIRS',
} XCONTENT_SIGNATURE_TYPE;


//------------------------------------------------------------------------------
typedef struct _XCONTENT_SIGNATURE {
    BYTE    Signature[256];
    BYTE    Reserved[296];
} XCONTENT_SIGNATURE, *PXCONTENT_SIGNATURE;


C_ASSERT(sizeof(XE_CONSOLE_SIGNATURE) == sizeof(XCONTENT_SIGNATURE));


//------------------------------------------------------------------------------

#define XCONTENT_UNRESTRICTED_LICENSEE          ((ULONGLONG) 0xFFFFFFFFFFFFFFFF)

#define XCONTENT_LICENSE_FLAG_REQUIRE_ONLINE    0x00000001

typedef struct _XCONTENT_LICENSE {
      ULONGLONG     LicenseeId;
      DWORD         LicenseBits;
      DWORD         LicenseFlags;  
} XCONTENT_LICENSE, *PXCONTENT_LICENSE;


//------------------------------------------------------------------------------
typedef struct _XCONTENT_HEADER {

    //
    // Indicates how the content was signed.
    //
    XCONTENT_SIGNATURE_TYPE SignatureType;

    //
    // Signature information.  The signature covers the remainder of this
    // XCONTENT_HEADER structure starting immediately after the signature
    // field.
    //
    union {
        XE_CONSOLE_SIGNATURE    ConsoleSignature;
        XCONTENT_SIGNATURE      ContentSignature;
    } Signature;

    //
    // Licensing information a fixed array of 16 license descriptors.
    //
    XCONTENT_LICENSE        LicenseDescriptors[16];

    //
    // ContentId is the SHA-1 digest of the XCONTENT_METADATA header and all
    // subsequent headers.  This digests everything up to the start of the
    // package file system blob, including the alignment padding, even though
    // the padding is not included in SizeOfHeaders below.  In other words,
    // round the SizeOfHeaders value up to the next alignment boundary, then
    // subtract sizeof(XCONTENT_HEADER), and that's how many bytes to hash
    // starting after immediately this XCONTENT_HEADER structure.
    //
    BYTE                    ContentId[XECRYPT_SHA_DIGEST_SIZE];

    //
    // Specifies the total size of useable header information, including this
    // header, but not including any alignment padding (even though the
    // padding is included in the ContentId digest).
    //
    ULONG                   SizeOfHeaders;
} XCONTENT_HEADER, *PXCONTENT_HEADER;


//------------------------------------------------------------------------------
#define XCONTENT_THUMBNAIL_WIDTH    64
#define XCONTENT_THUMBNAIL_HEIGHT   64
#define XCONTENT_THUMBNAIL_BITDEPTH 32
#define XCONTENT_THUMBNAIL_SIZE     (XCONTENT_THUMBNAIL_WIDTH * XCONTENT_THUMBNAIL_HEIGHT * (XCONTENT_THUMBNAIL_BITDEPTH / 8))

typedef struct _XCONTENT_METADATA {

    //
    // Type of content represented (XCONTENTTYPE_*).
    //
    DWORD               ContentType;

    //
    // Reserved value for future extensibility, must be zero.
    //
    DWORD               Reserved1;

    //
    // Size of file system blob after headers.  Note that some helper routines
    // choose to add in the size of the header block as well when passing this
    // information around for convenience, but in storage/when hashed this
    // should only include the file system blob.
    //
    LARGE_INTEGER       ContentSize;

    //
    // Execution ID of the title for which content package was generated.
    //
    XEX_EXECUTION_ID    ExecutionId;

    //
    // ID of console on which this content was created, or all zeros if not
    // created by a console.
    //
    BYTE                ConsoleId[CONSOLE_ID_SIZE];

    //
    // XUID of user that created this content package, or all zeros if not
    // created by a user.
    //
    ULONGLONG           Creator;

    //
    // Root digest of files and other information generated by the embedded
    // file system.
    //
    BYTE                StfsVolumeDescriptor[36];

    //
    // Reserved bytes for future extensibility, must be zero.
    //
    BYTE                Reserved2[96];

    //
    // ID of device on which content package was created.
    //
    BYTE                DeviceId[20];

    //
    // Display name for content package.
    //
    WCHAR               DisplayName[9][XCONTENT_MAX_DISPLAYNAME_LENGTH];

    //
    // Description of content package.
    //
    WCHAR               Description[9][XCONTENT_MAX_DISPLAYNAME_LENGTH];

    //
    // Name of publisher of content package.
    //
    WCHAR               Publisher[64];

    //
    // Title Name for content package.
    //
    WCHAR               TitleName[64];

    //
    // Package flags.
    //
    union {
        struct {
            //
            // Bit indicating whether this content package may be transferred
            // to another profile.
            //
            BYTE        ProfileTransfer   : 1;

            //
            // Bit indicating whether this content package may be transferred
            // to another device.
            //
            BYTE        DeviceTransfer    : 1;

            //
            // Reserved bits, must be 0.
            //
            BYTE        Reserved          : 6;
        } Bits;
        BYTE            FlagsAsBYTE; 
    } Flags;

    //
    // Embedded content package thumbnail size in bytes.
    //
    DWORD               ThumbnailSize;

    //
    // Embedded content package title thumbnail size in bytes.
    //
    DWORD               TitleThumbnailSize;

    //
    // Embedded content package thumbnail graphic icon.
    //
    BYTE                Thumbnail[XCONTENT_THUMBNAIL_SIZE];

    //
    // Embedded content package title thumbnail graphic icon.
    //
    BYTE                TitleThumbnail[XCONTENT_THUMBNAIL_SIZE];

} XCONTENT_METADATA, *PXCONTENT_METADATA;


//------------------------------------------------------------------------------
typedef struct _XCONTENT_METADATA_TITLE_CONTENT {

    //
    // Reserved, must be zero.  This is used to make the structure the same
    // size as XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE (when part of the
    // XCONTENT_METADATA_INSTALLER structure).
    //
    BYTE                Reserved[5620];
} XCONTENT_METADATA_TITLE_CONTENT;


//------------------------------------------------------------------------------
typedef struct _XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE {

    //
    // Current version for which update applies, or 0 for all derivatives of
    // the base version.
    //
    DWORD               CurrentVersion;

    //
    // New version to which the update will upgrade.
    //
    DWORD               NewVersion;

    //
    // Reserved, must be zero.  This is used to make the structure the same
    // size as XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE when combined with
    // the XCONTENT_METADATA_INSTALLER structure.
    //
    BYTE                Reserved[5608];
} XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE;


//------------------------------------------------------------------------------
typedef struct _XCONTENT_METADATA_INSTALLER_TITLE_UPDATE {

    //
    // System version to which update is restricted, or 0 for all system
    // versions.
    //
    DWORD               SystemVersion;

    //
    // New version to which the update will upgrade.
    //
    DWORD               NewVersion;

    //
    // Reserved, must be zero.  This is used to make the structure the same
    // size as XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE when combined with
    // the XCONTENT_METADATA_INSTALLER structure.
    //
    BYTE                Reserved[5608];
} XCONTENT_METADATA_INSTALLER_TITLE_UPDATE;


//------------------------------------------------------------------------------
typedef struct _XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE {

    //
    // Download installer progress cache information.
    //
    XONLINECONTENT_RESUME_HEADER    ResumeHeader;

    //
    // Extra storage space for CAB resume information.
    //
    BYTE                            CabResumeData[XONLINECONTENT_MAX_SINGLE_FILE_RESUME_DATA_SIZE];
} XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE;


//------------------------------------------------------------------------------
typedef enum _INSTALLER_METADATA_TYPE
{
    INSTALLER_METADATA_TYPE_SYSTEM_UPDATE                   = 'SUPD',
    INSTALLER_METADATA_TYPE_TITLE_UPDATE                    = 'TUPD',
    INSTALLER_METADATA_TYPE_PROGRESS_CACHE_SYSTEM_UPDATE    = 'P$SU',
    INSTALLER_METADATA_TYPE_PROGRESS_CACHE_TITLE_UPDATE     = 'P$TU',
    INSTALLER_METADATA_TYPE_PROGRESS_CACHE_TITLE_CONTENT    = 'P$TC',
} INSTALLER_METADATA_TYPE;


//------------------------------------------------------------------------------
typedef struct _XCONTENT_METADATA_INSTALLER {

    //
    // Type of installer package.
    //
    INSTALLER_METADATA_TYPE     MetaDataType;

    //
    // Union of type specific metadata structures.
    //
    union {
        XCONTENT_METADATA_INSTALLER_SYSTEM_UPDATE   SystemUpdate;
        XCONTENT_METADATA_INSTALLER_TITLE_UPDATE    TitleUpdate;
        XCONTENT_METADATA_INSTALLER_PROGRESS_CACHE  InstallProgressCache;
    } MetaData;
} XCONTENT_METADATA_INSTALLER;

C_ASSERT(sizeof(XCONTENT_METADATA_TITLE_CONTENT) == sizeof(XCONTENT_METADATA_INSTALLER));


//------------------------------------------------------------------------------

//
// Headers must be zero padded to meet this alignment requirement for the start
// of the embedded file system volume.
//
#define XCONTENT_FILE_SYSTEM_ALIGNMENT              (4 * 1024)
#define XCONTENT_ROUND_UP_TO_ALIGNMENT(size)        (((size) + (XCONTENT_FILE_SYSTEM_ALIGNMENT - 1)) & (~(XCONTENT_FILE_SYSTEM_ALIGNMENT - 1)))
#define XCONTENT_ALIGNMENT_PADDING_NEEDED(size)     (XCONTENT_ROUND_UP_TO_ALIGNMENT(size) - (size))

//
// The file system blob/tools expect to deal with volumes that are marked as
// having sizes that are even multiples of a megabyte.
//
#define XCONTENT_FILE_SYSTEM_VOLUME_SIZE_UNITS      (1024 * 1024)
#define XCONTENT_ROUND_UP_TO_VOLUME_SIZE(size)      (((size) + (XCONTENT_FILE_SYSTEM_VOLUME_SIZE_UNITS - 1)) & (~(XCONTENT_FILE_SYSTEM_VOLUME_SIZE_UNITS - 1)))


//
// Define reasonable maximum values for content package header fields (or
// implied values).  The constants are somewhat arbitrary, but chosen to be
// small enough so as to to avoid 32 bit integer overflow issues.  This
// simplifies validation for the consumer to just needing to validate the
// individual pieces against their respective values.
//
#define XCONTENT_MIN_HEADERS_SIZE                   (sizeof(XCONTENT_HEADER) + sizeof(XCONTENT_METADATA))
#define XCONTENT_MAX_OTHER_METADATA_SIZE            0x01000000
#define XCONTENT_MAX_HEADERS_SIZE                   0x10000000

C_ASSERT(((DWORD) XCONTENT_MAX_HEADERS_SIZE + (DWORD) sizeof(XCONTENT_HEADER)) > (DWORD) XCONTENT_MAX_HEADERS_SIZE);
C_ASSERT(((DWORD) XCONTENT_MAX_HEADERS_SIZE + (DWORD) sizeof(XCONTENT_HEADER) + (DWORD) sizeof(XCONTENT_METADATA)) > (DWORD) XCONTENT_MAX_HEADERS_SIZE);
C_ASSERT(((DWORD) XCONTENT_MAX_HEADERS_SIZE + (DWORD) sizeof(XCONTENT_HEADER) + (DWORD) sizeof(XCONTENT_METADATA) + (DWORD) XCONTENT_MAX_OTHER_METADATA_SIZE) > (DWORD) XCONTENT_MAX_HEADERS_SIZE);
C_ASSERT(((DWORD) XCONTENT_MAX_HEADERS_SIZE + (DWORD) sizeof(XCONTENT_HEADER) + (DWORD) sizeof(XCONTENT_METADATA) + (DWORD) XCONTENT_MAX_OTHER_METADATA_SIZE + (DWORD) XCONTENT_FILE_SYSTEM_ALIGNMENT) > (DWORD) XCONTENT_MAX_HEADERS_SIZE);

#define XCONTENT_MIN_CONTENT_SIZE                   256
#define XCONTENT_MAX_CONTENT_SIZE                   0x00000000FFFFFFFF


#pragma pack(pop)


#endif // _CONTENTPKG_H_
